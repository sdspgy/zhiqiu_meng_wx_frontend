{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst fs = require('fs');\nconst path = require('path');\nconst pify = require('pify');\n\nconst defaults = {\n\tmode: 0o777 & (~process.umask()),\n\tfs\n};\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n\tif (process.platform === 'win32') {\n\t\tconst pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''));\n\n\t\tif (pathHasInvalidWinCharacters) {\n\t\t\tconst err = new Error(`Path contains invalid characters: ${pth}`);\n\t\t\terr.code = 'EINVAL';\n\t\t\tthrow err;\n\t\t}\n\t}\n};\n\nmodule.exports = (input, opts) => Promise.resolve().then(() => {\n\tcheckPath(input);\n\topts = Object.assign({}, defaults, opts);\n\n\tconst mkdir = pify(opts.fs.mkdir);\n\tconst stat = pify(opts.fs.stat);\n\n\tconst make = pth => {\n\t\treturn mkdir(pth, opts.mode)\n\t\t\t.then(() => pth)\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\tif (err.message.includes('null bytes') || path.dirname(pth) === pth) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn make(path.dirname(pth)).then(() => make(pth));\n\t\t\t\t}\n\n\t\t\t\treturn stat(pth)\n\t\t\t\t\t.then(stats => stats.isDirectory() ? pth : Promise.reject())\n\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t});\n\t\t\t});\n\t};\n\n\treturn make(path.resolve(input));\n});\n\nmodule.exports.sync = (input, opts) => {\n\tcheckPath(input);\n\topts = Object.assign({}, defaults, opts);\n\n\tconst make = pth => {\n\t\ttry {\n\t\t\topts.fs.mkdirSync(pth, opts.mode);\n\t\t} catch (err) {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\tif (err.message.includes('null bytes') || path.dirname(pth) === pth) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\n\t\t\t\tmake(path.dirname(pth));\n\t\t\t\treturn make(pth);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (!opts.fs.statSync(pth).isDirectory()) {\n\t\t\t\t\tthrow new Error('The path is not a directory');\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\treturn pth;\n\t};\n\n\treturn make(path.resolve(input));\n};\n"]}